# MIPS Pt2 - Instruction Formats

**Note:** Unless otherwise stated, assume that any n-bit binary number is n-bit
unsigned binary.

In MIPS, all instructions are 32-bits (Or a word) wide. There are a total of
three instruction formats:

* R-Format: Where the R stands for "register". This format of instructions is
  used mainly for operations that involve registers only
* I-Format: Where the I stands for "immediate". This format of instructions is
  used mainly for data transfer operations and other operations that involve
  immediate values
* J-Format: Where the J stands for "japan". This is the worst format in
  existence and is a drain on social resources.

Every instruction in MIPS is translated into a single line of machine code
consisting of exactly 32 bits. Different portions of the 32-bit pattern
correspond directly to different portions of the MIPS code from which they were
translated from. For example, suppose you had the MIPS instruction:

```
add $t0, $s1, $s2
```

This instruction will translate to the following machine code:

```
000000 10001 10010 01000 00000 100000
```

The spaces have been added for readability. Every space-separated string of
bits is what we call a **field**. In the above, the first and last fields are
generated by the `add` keyword. The second and third fields are generated by
the register names `$s1` and `$s2` respectively. The fourth field is generated
by `$t0`. The fifth field is actually generated by the lack of something in the
MIPS code: A shift amount. Different instructions translate into different
permutations of 32 bits. (This means that there is a maximum of about 4 billion
unique instructions in MIPS).

The main difference between the three different formats above is in the way
they, well, *format* the fields of their resulting machine codes. Different
formats have different numbers of fields as well as different bit-widths for
each field.

In the subsequent sections, we will take a closer look at each format
individually. But for now, I should mention one specific field of particular
importance, the **opcode**. The opcode is a field that is common to all three
formats. The first six bits of every line of machine code is the opcode of that
instruction. In addition to telling the machine which operation should be
performed, the opcode is also responsible for telling the machine what format
the following bits are in. Without the opcode, the machine would have no way of
interpreting the rest of the bit pattern.

## R-Format

R-Format instructions format their 32-bit machine code in the following way:

| op     | rs     | rt     | rd     | shamt  | funct  |
| ------ | ------ | ------ | ------ | ------ | ------ |
| 6-bits | 5-bits | 5-bits | 5-bits | 5-bits | 6-bits |

Where each field is:
* op - the opcode; tells the machine that the following instruction is in
  R-Format. In addition, it works in conjunction with the *funct* field to
  specify which R-Format instruction this is
* rs - the first source register; tells the machine which register's data will
  be used as the first operand in the operation
* rt - the second source register; tells the machine which register's data will
  be used as the second operand in the operation
* rd - the destination register; tells the machine which register should be
  used to store the result of the operation
* shamt - the shift amount; used exclusively during a few select instructions,
  including `sll` and `srl`
* funct - the function; the value in this field, in conjunction with the
  opcode, tells the machine exactly what operation to perform

We have already seen an example of an R-format instruction in the form of an
`add` from earlier.

### Bitwise Operations

Traditionally, there is a set of operations that are performed directly on bit
patterns, regardless of what the patterns actually represent. These operations
are called **bitwise operations** and have been implemented in MIPS via
R-format instructions.

#### Shift Left

The first of these bitwise operations is the **shift left** operation. Exactly
what it sounds like, when you perform a shift left operation on a bit pattern,
you are shifting the bits to the left by a certain offset.

Implementing this operation in MIPS is an instruction called `sll`, which
stands for *shift left logic*:

```
sll $1, $2, 4
```

The above will take the bit pattern inside of register `$2`, shift all the bits
left by 15 places, and store the result inside of `$1`. Note that this is not
a *smart* operation: It does not care about what the bit pattern is actually
representing. It will toss away any bits that exceed the 32-bit width of the
registers, and the spaces freed up on the right side will be zero-filled! For
example, if the bit pattern in `$2` was:

```
1111 0000 0110 1111 0000 1010 0101 1001
```

Then the result of the above `sll` would be:

```
0000 0110 1111 0000 1010 0101 1001 0000
```

The above `sll` instruction is translated into:

```
000000 00000 00010 00001 00100 000000
```

The `sll` instruction generates `000000` for both the op and funct fields. The
instruction, along with `srl`, does not use the rs field, hence it is `00000`.
The rt field is given the register `$2`, hence it is `00010`. The rd field is
given the register `$1`, hence it is `00001`. The shamt field is finally used;
it holds the offset value of 4, which is `00100` in 5-bit binary.

Note that the maximum value for the shamt field is 32 since it is a 5-bit
binary. This may seem limiting, but remember that the width of our registers is
32 bits. As such, there should never be a need to shift any more than 32 bits.

#### Shift Right

Once we have seen shift left, shift right is fairly easy to understand. The
shift right operation is implemented in MIPS by the `srl` (Shift right logic)
instruction:

```
srl $3, $12, 4
```

The above will shift all the bits inside of register `$12` to the right by four
places and store the result inside of register `$3`.

Once again, just like shift left, any bits that "fall off the edge" will be
discarded. Additionally, any space created on the left side will be
zero-filled.

The machine code generated by `srl` is also very similar to `sll`: The rs field
will still be 0, and the shamt field will hold the offset. The op field will be
`000000`, but the funct field for `srl` will be `000010`.

### AND

The next bitwise operation is the **AND** operation. In MIPS, this is
implemented by the `and` instruction:

```
and $1, $2, $3
```

The above instruction will use the contents of register `$2` and the contents
of register `$3` for a bit-by-bit comparison. For every bit, it will write down
a 1 if both bit patterns have a 1. Otherwise, it writes down a 0. The result of
the comparison is then stored inside of `$1`.

For example, if the comparison was between these two bit patterns:
```
0101 # pattern A
0011 # pattern B
```
The resulting bit pattern would be:
```
0001
```

For the way it behaves, the AND operation is also sometimes called a *mask*.
Notice that in the above example, in the positions where pattern A had a 1, the
resulting pattern has the same bit as pattern B in the same position. In this
sense, pattern A "masks" over pattern B: We can alter pattern A to show certain
bits of B and not the others.

For this and the following bitwise instructions, I will not bother with trying
to translate them into machine code. They are very similar to `add` and `sub`.

### OR

The bitwise operation OR is very similar to AND. It is implemented in MIPS by,
you've guessed it, the `or` instruction:

```
or $1, $2, $3
```

Once again, a bit-by-bit comparison is done between registers `$2` and `$3`,
the results of which will be stored inside register `$1`. In an OR operation,
a 1 is recorded as long as at least one of the bits is a 1. Otherwise, a 0 is
recorded.

For example, if the two patterns were:
```
0101
0011
```
The resulting pattern would be:
```
0111
```

### NOR

You must be thinking, "Surely there must be a way to perform the most obvious
of all bitwise operations, that of flipping the bits, right?" Well, the smart
folks who designed MIPS thought differently. In MIPS, there are no dedicated
instructions for flipping the bits in a bit pattern. Instead, what you have is
the `nor` instruction.

In MIPS, the `nor` instruction, as you would imagine, performs a NOR bitwise
operation:

```
nor $1, $2, $3
```

What exactly does that mean? Take the above as an example. Similar to the other
ones before, a bit-by-bit comparison is made between the contents of `$2` and
the contents of `$3`. Except this time, a 1 is recorded if and only if both of
the bit patterns have a 0 at that position. Otherwise, a 0 is recorded.

As a demonstration, suppose you had the bit patterns:
```
0101
0011
```
Then the result of a NOR operation between them would be:
```
1000
```

So what all of this have to do with the bit-flip operation? See, there is a
little trick that you can do with the NOR operation to achieve the effects of
flipping the bits in a bit pattern. Due to the way the operation is defined, if
you tried to NOR any bit with a 0, you will get the opposite of that bit: 1 NOR
0 is 0, and 0 NOR 0 is 1! Therefore, suppose that you wanted to flip the bits
of the value stored inside of register `$3` and store the result in register
`$1`, you may accomplish this with NOR:

```
nor $1, $0, $3 # to flip $x, use $x as either rs or rt and $0 for the other
```

## I-format

I-format instructions format their 32-bit machine code in the following way:

| op     | rs     | rt     | constant or address      |
| ------ | ------ | ------ | ------------------------ |
| 6-bits | 5-bits | 5-bits | 16-bits Signed           |

Where each field is:
* op - the opcode; tells the machine to interpret the bit pattern as an
  I-format instruction; also says what instruction it is
* rs - the source register; depending on the specific operation, the contents
  of this register will be used in some way in conjunction with the immediate
  value
* rt - the target register; the result of the operation will be stored inside
  of this register
* constant/address - the immediate value; depending on the specific operation,
  the literal value represented by the bit pattern in this field will be used
  in some way in conjunction with the contents of the register from rs

An example of the I-format instruction is `addi` (Add Immediate):

```
addi $s1, $s2, 100
```

The above will take the contents of `$s2`, add 100 to it, and store the results
inside of `$s1`. This instruction is translated to:

```
001000 10010 10001 0000000001100100
```

This is because the opcode for `addi` is 8, which is `001000` in 6-bit binary.
The rs field gets the register `$s2`, which is another name for the 18th
register, and `10010` is 18 in 5-bit binary. Similarly, the rt field gets the
register `$s1`, which is the 17th register, thus the `10001`. Lastly, `100` in
16-bit signed binary is `0000000001100100`.

Notice that, for some reason, the ordering of the registers is reversed. This
was a phenomenon found in R-format instructions as well

The above highlights a limitation with `addi`. Because we only have 16 (signed)
bits to work with, the range of possible values we can add by is limited. The
largest value we can add is 2<sup>15</sup>-1; on the other hand, the lowest
value we can add is -2<sup>15</sup>.

### Memory Read/Write

I-format instructions are also used for reading from and writing to the memory.
The `lw` (Load Word) instruction is used to read in a word from the memory:

```
lw $3, 72($4)
```

The above will take the contents of `$4`, treat it as an address in data
memory, go forward by 72 bytes, take the contents of the next word, and store
it inside of `$3`. This instruction is translated to:

```
100011 00100 00011 0000000001001000
```

The opcode for `lw` is 35, which is `100011`. The rs field gets `$4`, which is
`00100`. The rt field gets `$3`, which is `00011`. Lastly, 72 is, well, the bit
pattern given above, in 16-bit signed binary. Once again, because we have only
16 bits for the constant field, we are limited in terms of where we can read
from. Since the sequence is interpreted as a 16-bit signed binary, we can only
load words from either 2<sup>15</sup>-1 bytes ahead or -2<sup>15</sup> bytes
behind of the address stored in the source register. One important thing to
note is that because the MIPS architecture uses *alignment restriction*, it is
important for the programmer to make sure that the address they are attempting
to access (Which is given by the addition of the constant to the address found
in source register) is a *multiple of 4*.

The butter to `lw`'s bread is `sw`. The `sw` (Store Word) instruction writes a
word into memory:

```
sw $4, 124($2)
```

The above instruction will copy the contents of `$4`, go to the address stored
in `$2`, advance by 124 bytes, and write the contents of `$4` in the next four
bytes. This instruction is translated into:

```
101011 00010 00100 0000000001111100
```

The translation is fairly straight-forward; the opcode of `lw` is `101011`,
which is 43.  Once again, the limitation that applied to `lw` also applies to
`sw`.

### Branching Instructions

In MIPS, instructions are executed sequentially until the end of the program is
reached (Or until some other form of termination occurs). However, there are
several families of instructions who can alter this control flow. One such
family are the *branch* instructions. These instructions are all in R-format.
Their functionalities all revolve the same idea: Test something, and change the
control flow if the test was successful.

Here, we will look at two instructions within this family. The first is the
`beq` (Branch if Equals) instruction. Its premises are simple: Check the
contents of two registers, if they are equal, move the *program counter* (PC)
according to the constant given. As an example:

```
beq $3, $4, 100
```

The above instruction will compare the contents of `$3` and `$4`. If they are
exactly the same, the PC will be advanced by 100 words. Did you get that? I'll
say it again: The PC will be advanced by 100 **words**. This makes sense,
right? Since every instruction in MIPS is exactly one word in length, you
should never have the need to go to any address in instruction memory that is
not a multiple of four. As a more concrete example, suppose that the above
instruction happened to be at address 0 in instruction memory, if the test was
true, the program counter will be updated to 404. Wait, why? Well, remember
that the PC is updated at the same time an instruction is executed. So, by the
time the `beq` instruction is coming around to add 400 to the PC, it has
already updated itself to 4. Therefore, the next instruction to be executed
will be the one at address 404. The opcode for `beq` is `000100`, therefore,
the above instruction will be translated into:

```
000100 00100 00011 0000000001100100
```

The complement to `beq` is the `bne` (Branch if Not Equals) instruction. Its
logic is simple: Check the contents of two registers, if they are not equal,
then move the PC according to the constant given. As an example:

```
bne $9, $7, -24
```

The above instruction will compare the contents of `$9` and `$7`. If they are
not the same, the PC will be set back by 24 words. Suppose that this
instruction is at address 100 in instruction memory, then, as the instruction
is executed, the PC will be set to 104. If the test is successful, the PC will
be set to address 8 (104 - 24*4). The opcode for `bne` is `000101`, therefore,
the above instruction will be translated into:

```
000101 00111 01001 1111111111101000
```

Assembly language, believe it or not, does actually try to make the lives of
programmers easier. MIPS addresses the tedium of managing branch addresses with
its **label** mechanism. More will be said about MIPS labels in another
document (Probably), but as of right now, just think of it as being a way of
giving a more meaningful alias to the addresses of instructions in memory.



## J-Format
